<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MINEML (v1.29 - Pro Movement)</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #111;
            color: white;
            cursor: default; 
            user-select: none;
        }
        canvas {
            display: block;
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 24px;
            cursor: pointer;
        }
        #instructions {
            width: 50%;
            background: rgba(0, 0, 0, 0.5); 
            padding: 20px;
            border-radius: 8px;
            box-sizing: border-box; 
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin-left: -11px; 
            margin-top: -11px;
            font-size: 20px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none; 
            display: none; 
        }
        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            border-radius: 4px;
            pointer-events: none; 
        }
        .slot {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #555;
            box-sizing: border-box; 
            
            background-size: 32px; 
            background-repeat: no-repeat;
            background-position: center;
            image-rendering: pixelated; 
        }
        .slot.selected {
            border: 2px solid #FFF;
            background-color: rgba(255, 255, 255, 0.3); 
        }
        #inventory-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none; 
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }
        #creative-grid {
            display: grid;
            grid-template-columns: repeat(7, 54px); 
            gap: 4px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
        }
        #inventory-screen #hotbar {
            position: relative; 
            bottom: auto;
            left: auto;
            transform: none;
            pointer-events: auto; 
        }
        #inventory-screen .slot {
            cursor: pointer; 
            pointer-events: auto;
        }
        #inventory-screen .slot:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        #held-item {
            position: absolute;
            width: 32px;
            height: 32px;
            background-size: 32px;
            background-repeat: no-repeat;
            image-rendering: pixelated;
            pointer-events: none; 
            display: none; 
            z-index: 9999;
        }
        #version {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
            display: none; 
            user-select: none;
        }
        #controls-hint {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            display: none; 
            user-select: none;
        }
        #controls-display {
            position: absolute;
            top: 40px; 
            left: 10px;
            font-size: 14px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.9);
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 4px;
            pointer-events: none;
            display: none; 
            user-select: none;
        }
        #fly-mode-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 16px;
            color: #00ff00;
            font-weight: bold;
            display: none; 
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1>MINEML(v1.29)</h1>
            <p>Kliknij, aby rozpocząć</p>
            <p id="loading-message" style="font-size: 16px; color: #ccc;">Ładowanie tekstur...</p>
        </div>
    </div>

    <div id="crosshair">+</div>

    <div id="hotbar">
        <div class="slot"></div>
        <div class="slot"></div>
        <div class="slot"></div>
        <div class="slot"></div>
        <div class="slot"></div>
        <div class="slot"></div>
        <div class="slot"></div>
        <div class="slot"></div>
        <div class="slot"></div>
    </div>
    
    <div id="version">MINEML (v1.29)</div>
    <div id="controls-hint">Naciśnij [H] aby przełączyć pomoc</div>
    <div id="fly-mode-indicator">TRYB LATANIA</div>
    
    <div id="controls-display" style="display: none;"> 
        <b>Chodzenie:</b> W, A, S, D<br>
        <b>Sprint:</b> SHIFT<br> 
        <b>Skok / Góra:</b> SPACJA<br>
        <b>Latanie:</b> Podwójna SPACJA<br>
        <b>Dół (Latanie):</b> C<br> 
        <b>Niszcz:</b> LPM<br>
        <b>Buduj:</b> PPM<br>
        <b>Hotbar:</b> Kółko myszy<br>
        <b>Ekwipunek:</b> E<br>
        <b>Wyjście:</b> ESC
    </div>

    <div id="inventory-screen">
        <div id="creative-grid"></div>
    </div>
    
    <div id="held-item"></div>

    <!-- Import Map -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <!-- Główny skrypt gry -->
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let camera, scene, renderer, controls;
        let raycaster;
        
        const objects = []; 
        const BLOCK_SIZE = 1;

        const blockGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        
        const loadingManager = new THREE.LoadingManager();
        const textureLoader = new THREE.TextureLoader(loadingManager);
        
        const texturePath = 'resources/textures/blocks/'; 
        const itemsPath = 'resources/textures/items/';
        
        function loadTexture(fileName) {
            const texture = textureLoader.load(texturePath + fileName);
            texture.magFilter = THREE.NearestFilter; 
            return texture;
        }

        // --- Tekstury ---
        const dirtTexture = loadTexture('dirt.png');
        const stoneTexture = loadTexture('stone.png');
        const cobblestoneTexture = loadTexture('cobblestone.png');
        const leavesTexture = loadTexture('leaves_oak.png');
        const planksTexture = loadTexture('planks_oak.png');
        const logSideTexture = loadTexture('log_oak.png');
        const logTopTexture = loadTexture('log_oak_top.png');
        const grassTopTexture = loadTexture('grass_block_top.png');
        
        // --- Materiały ---
        const dirtMaterial = new THREE.MeshLambertMaterial({ map: dirtTexture });
        const stoneMaterial = new THREE.MeshLambertMaterial({ map: stoneTexture });
        const cobblestoneMaterial = new THREE.MeshLambertMaterial({ map: cobblestoneTexture });
        const planksMaterial = new THREE.MeshLambertMaterial({ map: planksTexture });
        
        const leavesMaterial = new THREE.MeshLambertMaterial({ 
            map: leavesTexture, 
            transparent: true, 
            alphaTest: 0.1, 
            side: THREE.DoubleSide
        });

        const logSideMaterial = new THREE.MeshLambertMaterial({ map: logSideTexture });
        const logTopMaterial = new THREE.MeshLambertMaterial({ map: logTopTexture });
        const logMaterialArray = [
            logSideMaterial, logSideMaterial, logTopMaterial,
            logTopMaterial, logSideMaterial, logSideMaterial
        ];

        const grassTopMaterial = new THREE.MeshLambertMaterial({ map: grassTopTexture });
        const grassBlockMaterialArray = [
            dirtMaterial, dirtMaterial, grassTopMaterial,
            dirtMaterial, dirtMaterial, dirtMaterial
        ];
        
        const blockInfo = {
            'dirt': { material: dirtMaterial, texture: texturePath + 'dirt.png' },
            'stone': { material: stoneMaterial, texture: texturePath + 'stone.png' },
            'cobblestone': { material: cobblestoneMaterial, texture: texturePath + 'cobblestone.png' },
            'planks': { material: planksMaterial, texture: texturePath + 'planks_oak.png' },
            'log': { material: logMaterialArray, texture: texturePath + 'log_oak.png' },
            'leaves': { material: leavesMaterial, texture: texturePath + 'leaves_oak.png' },
            'grass': { material: grassBlockMaterialArray, texture: texturePath + 'grass_block_top.png' },
            
            'pickaxe': { material: null, texture: itemsPath + 'diamond_pickaxe.png' },
            'sword': { material: null, texture: itemsPath + 'diamond_sword.png' },
            'apple': { material: null, texture: itemsPath + 'apple.png' }
        };
        
        const creativeItems = [
            'pickaxe', 'sword', 'apple', 
            'grass', 'dirt', 'stone', 'cobblestone', 'planks', 'log', 'leaves'
        ];
        
        let slotMaterials = new Array(9).fill(null);
        let hotbarItems = [
            'pickaxe', 'sword', 'grass', 'stone', 'planks', 'log', 'leaves', 'apple', null
        ];
        
        let heldItem = null; 
        let isInventoryOpen = false;


        // --- Zmienne fizyki (Ulepszone v1.29) ---
        const PLAYER_HEIGHT = 1.8 * BLOCK_SIZE;
        const PLAYER_WIDTH = 0.6; // Zmniejszone z 0.8 dla lepszego przeciskania się
        
        // Input states
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let jumpRequested = false; 
        let moveDown = false; 
        let isSprinting = false; 
        let isFlying = false;
        let isGrounded = false;

        // Physics State
        const velocity = new THREE.Vector3(); // Prawdziwy wektor prędkości (momentum)
        
        // Stałe fizyczne (Dostrojone do "MC Feel")
        const GRAVITY = 32.0; // Mocna grawitacja (była 20)
        const JUMP_FORCE = 9.5; // Impuls skoku (około 1.2 bloku)
        
        const WALK_SPEED = 4.3; // ~4.3 m/s w MC
        const SPRINT_SPEED = 6; // ~5.6 m/s w MC
        const FLY_SPEED = 10.9; // Creative fly speed

        // Tarcie (Damping)
        const GROUND_FRICTION = 10.0; // Szybkie zatrzymywanie na ziemi
        const AIR_FRICTION = 1.0; // Małe tarcie w powietrzu (zachowanie pędu)
        const FLY_FRICTION = 5.0; // Tarcie podczas latania

        const ACCELERATION = 50.0; // Jak szybko nabieramy prędkości
        
        let lastSpaceTime = 0;
        const DOUBLE_PRESS_DELAY = 300; 

        // --- Zmienne interakcji ---
        let isBreakingHeld = false, isPlacingHeld = false;
        const breakCooldown = 0.3, placeCooldown = 0.25; 
        let nextBreakTime = 0, nextPlaceTime = 0; 
        let breakHoldTime = 0, placeHoldTime = 0;   
        const breakMaxAccelTime = 1.5, placeMaxAccelTime = 1.0; 
        const breakMinCooldown = 0.1, placeMinCooldown = 0.1; 
        let prevTime = performance.now(); 

        // --- UI ---
        let hotbarContainer; 
        let hotbarSlots = []; 
        let currentSlot = 0; 
        let inventoryScreen, creativeGrid, heldItemVisual;
        let versionDisplay, controlsHint, controlsDisplay, flyModeIndicator;
        let controlsVisible = false; 

        loadingManager.onLoad = () => {
            const loadingMessage = document.getElementById('loading-message');
            if (loadingMessage) loadingMessage.textContent = "Kliknij, aby rozpocząć";
            init();
            animate();
        };
        
        loadingManager.onError = (url) => {
            const loadingMessage = document.getElementById('loading-message');
            if (loadingMessage) {
                loadingMessage.textContent = "Kliknij, aby rozpocząć (Brakujące tekstury będą czarne)";
                loadingMessage.style.color = "yellow";
            }
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 0); 

            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject()); 

            controls.addEventListener('lock', () => {
                blocker.style.display = 'none';
                crosshair.style.display = 'block';
                versionDisplay.style.display = 'block';
                controlsHint.style.display = 'block';
                if (isFlying) flyModeIndicator.style.display = 'block';
                inventoryScreen.style.display = 'none';
                document.body.style.cursor = 'none';
            });
            
            controls.addEventListener('unlock', () => {
                document.body.style.cursor = 'default';
                if (isInventoryOpen) {
                    blocker.style.display = 'none';
                    inventoryScreen.style.display = 'flex';
                } else {
                    blocker.style.display = 'flex';
                    inventoryScreen.style.display = 'none';
                }
                crosshair.style.display = 'none';
                versionDisplay.style.display = 'none';
                controlsHint.style.display = 'none';
                controlsDisplay.style.display = 'none'; 
                flyModeIndicator.style.display = 'none';
                controlsVisible = false; 
                
                // Reset inputów
                moveForward = moveBackward = moveLeft = moveRight = false;
                isBreakingHeld = isPlacingHeld = false;
                isSprinting = false;
                jumpRequested = false;
                moveDown = false;
            });
            
            blocker.addEventListener('click', () => {
                controls.lock();
            });

            const ambientLight = new THREE.AmbientLight(0x606060);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 0.75, 0.5).normalize();
            scene.add(directionalLight);

            const worldSize = 32; 
            const startX = -worldSize / 2;
            const startZ = -worldSize / 2;
            const groundDepth = 5; 

            for (let x = 0; x < worldSize; x++) {
                for (let z = 0; z < worldSize; z++) {
                     for (let y = 0; y > -groundDepth; y--) {
                         let material;
                         if (y === 0) material = grassBlockMaterialArray; 
                         else material = dirtMaterial; 

                         const block = new THREE.Mesh(blockGeometry, material);
                         // POPRAWKA v1.25: Przesunięcie o 0.5, by siatka pasowała
                         block.position.set(startX + x + 0.5, y - 0.5, startZ + z + 0.5);
                         block.name = "VOXEL_BLOCK"; 
                         scene.add(block);
                         objects.push(block);
                     }
                }
            }
            
            raycaster = new THREE.Raycaster();
            raycaster.far = 10; 

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('pointerdown', onPointerDown); 
            document.addEventListener('pointerup', onPointerUp);
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('contextmenu', (event) => event.preventDefault());
            window.addEventListener('wheel', onWheelScroll);
            
            hotbarContainer = document.getElementById('hotbar');
            hotbarSlots = Array.from(hotbarContainer.querySelectorAll('.slot'));
            inventoryScreen = document.getElementById('inventory-screen');
            creativeGrid = document.getElementById('creative-grid');
            heldItemVisual = document.getElementById('held-item');
            versionDisplay = document.getElementById('version');
            controlsHint = document.getElementById('controls-hint');
            controlsDisplay = document.getElementById('controls-display');
            flyModeIndicator = document.getElementById('fly-mode-indicator');

            inventoryScreen.appendChild(hotbarContainer);
            
            for (const itemName of creativeItems) {
                const info = blockInfo[itemName];
                const slot = document.createElement('div');
                slot.className = 'slot'; 
                slot.style.cursor = 'pointer';
                const textureUrl = info.texture;
                slot.style.backgroundImage = `url(${textureUrl})`;
                slot.addEventListener('click', () => onCreativeItemClick(itemName));
                creativeGrid.appendChild(slot);
            }
            
            for (let i = 0; i < 9; i++) {
                const itemName = hotbarItems[i];
                if (itemName) {
                    slotMaterials[i] = blockInfo[itemName].material;
                }
            }

            hotbarSlots.forEach((slot, index) => {
                slot.addEventListener('click', () => onHotbarSlotClick(index));
            });
            
            window.addEventListener('mousemove', (event) => {
                if (isInventoryOpen && heldItem) {
                    heldItemVisual.style.transform = `translate(${event.clientX}px, ${event.clientY}px)`;
                }
            });
            
            updateHotbarVisuals(); 
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function openInventory() {
            isInventoryOpen = true;
            controls.unlock(); 
        }
        
        function closeInventory() {
            isInventoryOpen = false;
            heldItem = null; 
            updateHeldItemVisual();
            controls.lock(); 
        }
        
        function onCreativeItemClick(itemName) {
            if (heldItem) heldItem = null;
            else heldItem = itemName;
            updateHeldItemVisual();
        }
        
        function onHotbarSlotClick(index) {
            const itemInSlot = hotbarItems[index];
            
            if (heldItem) {
                hotbarItems[index] = heldItem;
                slotMaterials[index] = blockInfo[heldItem].material;
                heldItem = itemInSlot; 
            } else if (itemInSlot) {
                hotbarItems[index] = null;
                slotMaterials[index] = null;
                heldItem = itemInSlot;
            }
            updateHotbarVisuals();
            updateHeldItemVisual();
        }

        function updateHeldItemVisual() {
            if (heldItem) {
                const info = blockInfo[heldItem];
                const textureUrl = info.texture;
                heldItemVisual.style.backgroundImage = `url(${textureUrl})`;
                heldItemVisual.style.display = 'block';
            } else {
                heldItemVisual.style.display = 'none';
            }
        }
        
        function onKeyDown(event) {
            if (event.code === 'KeyH') {
                if (controls.isLocked) { 
                    controlsVisible = !controlsVisible;
                    controlsDisplay.style.display = controlsVisible ? 'block' : 'none';
                }
                event.preventDefault(); 
                return; 
            }
            
            if (event.code === 'KeyE') {
                event.preventDefault();
                if (isInventoryOpen) closeInventory();
                else if (controls.isLocked) openInventory();
                return;
            }
            
            if (!controls.isLocked) return;

            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                
                case 'Space':
                    if (!event.repeat) { 
                        const currentTime = performance.now();
                        if (currentTime - lastSpaceTime < DOUBLE_PRESS_DELAY) {
                            isFlying = !isFlying;
                            velocity.y = 0; // Zresetuj pęd pionowy przy przełączeniu
                            flyModeIndicator.style.display = isFlying ? 'block' : 'none';
                            lastSpaceTime = 0; 
                        } else {
                            lastSpaceTime = currentTime;
                        }
                    }
                    jumpRequested = true; 
                    break;
                    
                case 'ShiftLeft': case 'ShiftRight': isSprinting = true; break;
                case 'KeyC': moveDown = true; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
                case 'Space': jumpRequested = false; break;
                case 'ShiftLeft': case 'ShiftRight': isSprinting = false; break;
                case 'KeyC': moveDown = false; break;
            }
        }

        function onPointerUp(event) {
            if (event.button === 0) isBreakingHeld = false;
            else if (event.button === 2) isPlacingHeld = false;
        }
        
        function handleBreaking() {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(objects, false);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                if (intersect.object.name === "VOXEL_BLOCK") {
                    scene.remove(intersect.object);
                    objects.splice(objects.indexOf(intersect.object), 1);
                }
            }
        }

        function handlePlacing() {
            const selectedMaterial = slotMaterials[currentSlot];
            if (!selectedMaterial) return; 
            
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(objects, false);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                
                const newBlock = new THREE.Mesh(blockGeometry, selectedMaterial);
                newBlock.name = "VOXEL_BLOCK"; 
                newBlock.position.copy(intersect.point).add(intersect.face.normal.clone().multiplyScalar(0.5));
                newBlock.position.divideScalar(BLOCK_SIZE).floor().multiplyScalar(BLOCK_SIZE).addScalar(BLOCK_SIZE / 2);
                
                updatePlayerBox(controls.getObject().position);
                const newBlockBox = new THREE.Box3();
                newBlockBox.setFromCenterAndSize(
                    newBlock.position, 
                    new THREE.Vector3(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE)
                );
        
                if (playerBox.intersectsBox(newBlockBox)) {
                    return; 
                }

                scene.add(newBlock);
                objects.push(newBlock);
            }
        }
        
        function onPointerDown(event) {
            if (!controls.isLocked) {
                if (event.target.id === 'blocker') controls.lock();
                return;
            }
            if (event.button === 0) isBreakingHeld = true;
            else if (event.button === 2) isPlacingHeld = true;
        }

        function onWheelScroll(event) {
            if (!controls.isLocked) return; 
            event.preventDefault(); 

            if (event.deltaY > 0) currentSlot = (currentSlot + 1) % 9;
            else if (event.deltaY < 0) currentSlot = (currentSlot - 1 + 9) % 9; 
            
            updateHotbarVisuals();
        }

        function updateHotbarVisuals() {
            if (controls.isLocked) {
                document.body.appendChild(hotbarContainer);
            } else if (isInventoryOpen) {
                inventoryScreen.appendChild(hotbarContainer);
            }
            
            hotbarSlots.forEach((slot, index) => {
                const itemName = hotbarItems[index];
                if (itemName) {
                    const info = blockInfo[itemName];
                    const textureUrl = info.texture;
                    slot.style.backgroundImage = `url(${textureUrl})`;
                } else {
                    slot.style.backgroundImage = 'none';
                }
                
                if (index === currentSlot) slot.classList.add('selected');
                else slot.classList.remove('selected');
            });
        }
        
        // --- Nowy System Fizyki (Wektory i Pęd) ---
        const playerBox = new THREE.Box3();
        const blockBox = new THREE.Box3();
        
        // Wektory pomocnicze (zadeklarowane raz, by nie śmiecić w RAMie)
        const directionVector = new THREE.Vector3();
        const forwardVector = new THREE.Vector3();
        const rightVector = new THREE.Vector3();
        const nextPosition = new THREE.Vector3();
        
        function updatePlayerBox(position) {
            playerBox.setFromCenterAndSize(
                position.clone().add(new THREE.Vector3(0, -PLAYER_HEIGHT / 2, 0)), 
                new THREE.Vector3(PLAYER_WIDTH, PLAYER_HEIGHT, PLAYER_WIDTH)
            );
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const currentTime = time / 1000.0;
            const delta = (time - prevTime) / 1000.0; 
            const effectiveDelta = Math.min(delta, 0.05);

            if (controls.isLocked) {
                
                if (hotbarContainer.parentNode !== document.body) {
                    document.body.appendChild(hotbarContainer);
                    updateHotbarVisuals(); 
                }

                // Logika niszczenia/budowania (bez zmian)
                if (isBreakingHeld) { breakHoldTime += effectiveDelta; } 
                else { breakHoldTime = 0; }
                if (isPlacingHeld) { placeHoldTime += effectiveDelta; } 
                else { placeHoldTime = 0; }

                const breakAccel = Math.min(1, breakHoldTime / breakMaxAccelTime);
                const placeAccel = Math.min(1, placeHoldTime / placeMaxAccelTime);
                const adjustedBreakCooldown = Math.max(breakMinCooldown, breakCooldown * (1 - 0.75 * breakAccel));
                const adjustedPlaceCooldown = Math.max(placeMinCooldown, placeCooldown * (1 - 0.75 * placeAccel));

                if (isBreakingHeld && currentTime > nextBreakTime) {
                    handleBreaking();
                    nextBreakTime = currentTime + adjustedBreakCooldown;
                }
                if (isPlacingHeld && currentTime > nextPlaceTime) {
                    handlePlacing();
                    nextPlaceTime = currentTime + adjustedPlaceCooldown;
                }

                // --- NOWA FIZYKA RUCHU (v1.29) ---

                // 1. Oblicz kierunek z Inputu (WASD)
                directionVector.z = Number(moveForward) - Number(moveBackward);
                directionVector.x = Number(moveRight) - Number(moveLeft);
                directionVector.normalize();

                // Przekształć kierunek lokalny na światowy (względem kamery)
                camera.getWorldDirection(forwardVector);
                forwardVector.y = 0;
                forwardVector.normalize();
                rightVector.crossVectors(forwardVector, camera.up).normalize();

                // Oblicz wektor *chęci* ruchu (Wish Direction)
                const wishDir = new THREE.Vector3();
                wishDir.add(forwardVector.multiplyScalar(directionVector.z));
                wishDir.add(rightVector.multiplyScalar(directionVector.x));
                wishDir.normalize();

                // 2. Ustal parametry w zależności od stanu (Lot / Ziemia / Powietrze)
                let currentMaxSpeed = isSprinting ? SPRINT_SPEED : WALK_SPEED;
                let friction = isGrounded ? GROUND_FRICTION : AIR_FRICTION;
                
                if (isFlying) {
                    currentMaxSpeed = isSprinting ? FLY_SPEED * 2 : FLY_SPEED;
                    friction = FLY_FRICTION;
                    isGrounded = false; // W locie nie jesteśmy uziemieni
                }

                // 3. Aplikuj Tarcie (Damping) - Zwalnianie
                // Zwalniamy tylko w osiach X/Z (Y jest dla grawitacji, chyba że latamy)
                velocity.x -= velocity.x * friction * effectiveDelta;
                velocity.z -= velocity.z * friction * effectiveDelta;
                if (isFlying) {
                    velocity.y -= velocity.y * friction * effectiveDelta;
                }

                // 4. Aplikuj Akcelerację (Input)
                // Dodajemy prędkość w kierunku ruchu
                if (directionVector.lengthSq() > 0) {
                    velocity.x += wishDir.x * ACCELERATION * effectiveDelta;
                    velocity.z += wishDir.z * ACCELERATION * effectiveDelta;
                }
                
                // 5. Ogranicz prędkość poziomą (Clamping)
                // Aby gracz nie rozpędzał się w nieskończoność
                const horizontalSpeed = Math.sqrt(velocity.x**2 + velocity.z**2);
                if (horizontalSpeed > currentMaxSpeed) {
                    // Skaluj w dół do max speed
                    const scale = currentMaxSpeed / horizontalSpeed;
                    velocity.x *= scale;
                    velocity.z *= scale;
                }

                // 6. Fizyka Wertykalna (Grawitacja / Skok / Lot)
                if (isFlying) {
                    if (jumpRequested) velocity.y += ACCELERATION * effectiveDelta;
                    if (moveDown) velocity.y -= ACCELERATION * effectiveDelta;
                } else {
                    // Grawitacja
                    velocity.y -= GRAVITY * effectiveDelta;
                    
                    // Skok (Impuls)
                    if (jumpRequested && isGrounded) {
                        velocity.y = JUMP_FORCE;
                        isGrounded = false;
                    }
                }

                // 7. Rozwiązywanie Kolizji i Aktualizacja Pozycji
                // Oblicz, gdzie chcemy być
                const currentPos = controls.getObject().position;
                nextPosition.copy(currentPos);
                
                // --- OŚ Y ---
                const deltaY = velocity.y * effectiveDelta;
                nextPosition.y += deltaY;
                updatePlayerBox(nextPosition);
                
                let collisionY = false;
                // Sprawdzamy bloki w pobliżu
                for(const obj of objects) {
                    if (obj.name === "VOXEL_BLOCK") {
                        // Szybki test dystansu
                        if (Math.abs(obj.position.x - currentPos.x) > 2 || 
                            Math.abs(obj.position.z - currentPos.z) > 2 ||
                            Math.abs(obj.position.y - currentPos.y) > 3) continue;

                        blockBox.setFromObject(obj);
                        if (playerBox.intersectsBox(blockBox)) {
                            // Kolizja wykryta
                            if (velocity.y < 0) { 
                                // Spadamy na blok
                                nextPosition.y = blockBox.max.y + PLAYER_HEIGHT + 0.001; 
                                velocity.y = 0;
                                isGrounded = true;
                                collisionY = true;
                            } else if (velocity.y > 0) { 
                                // Uderzamy głową
                                nextPosition.y = blockBox.min.y - 0.001;
                                velocity.y = 0;
                                collisionY = true;
                            }
                        }
                    }
                }
                if (!collisionY && !isFlying) isGrounded = false; // Spadamy
                currentPos.y = nextPosition.y;

                // --- OŚ X ---
                const deltaX = velocity.x * effectiveDelta;
                nextPosition.x += deltaX;
                updatePlayerBox(nextPosition);
                
                for(const obj of objects) {
                    if (obj.name === "VOXEL_BLOCK") {
                        if (Math.abs(obj.position.x - currentPos.x) > 2 || 
                            Math.abs(obj.position.z - currentPos.z) > 2 ||
                            Math.abs(obj.position.y - currentPos.y) > 3) continue;

                        blockBox.setFromObject(obj);
                        if (playerBox.intersectsBox(blockBox)) {
                            // Zatrzymaj ruch tylko w tej osi
                            velocity.x = 0;
                            // Cofnij ruch
                            nextPosition.x -= deltaX; 
                        }
                    }
                }
                currentPos.x = nextPosition.x;

                // --- OŚ Z ---
                const deltaZ = velocity.z * effectiveDelta;
                nextPosition.z += deltaZ;
                updatePlayerBox(nextPosition);
                
                for(const obj of objects) {
                    if (obj.name === "VOXEL_BLOCK") {
                        if (Math.abs(obj.position.x - currentPos.x) > 2 || 
                            Math.abs(obj.position.z - currentPos.z) > 2 ||
                            Math.abs(obj.position.y - currentPos.y) > 3) continue;

                        blockBox.setFromObject(obj);
                        if (playerBox.intersectsBox(blockBox)) {
                            velocity.z = 0;
                            nextPosition.z -= deltaZ;
                        }
                    }
                }
                currentPos.z = nextPosition.z;

            } else if (isInventoryOpen) {
                if (hotbarContainer.parentNode !== inventoryScreen) {
                    inventoryScreen.appendChild(hotbarContainer);
                    updateHotbarVisuals(); 
                }
            }

            prevTime = time;
            renderer.render(scene, camera);
        }
        
    </script>
</body>
</html>
